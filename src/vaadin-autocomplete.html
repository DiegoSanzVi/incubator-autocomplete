<!--
@license
Copyright (c) 2018 Vaadin Ltd.
This program is available under Commercial Vaadin Add-On License 3.0 (CVALv3).

See <a href="https://vaadin.com/license/cval-3">the website</a> for the complete license.
-->

<link rel="import" href="../../polymer/polymer-element.html">
<link rel="import" href="../../vaadin-themable-mixin/vaadin-themable-mixin.html">
<link rel="import" href="../../vaadin-element-mixin/vaadin-element-mixin.html">
<link rel="import" href="../../iron-resizable-behavior/iron-resizable-behavior.html">
<link rel="import" href="../../vaadin-text-field/vaadin-text-field.html">
<link rel="import" href="../../vaadin-list-box/vaadin-list-box.html">
<link rel="import" href="../../vaadin-item/vaadin-item.html">
<link rel="import" href="../../vaadin-button/vaadin-button.html">
<link rel="import" href="../../vaadin-icons/vaadin-icons.html">
<link rel="import" href="vaadin-autocomplete-overlay.html">

<dom-module id="vaadin-autocomplete">
  <template>
    <style>
      :host {
        display: inline-block;
      }

      :host([options-shown]) {
        pointer-events: auto;
      }

      [part="options-container"] {
        min-width: var(--vaadin-autocomplete-options-width);
        --_lumo-item-selected-icon-display: none;
      }

      [part="option"] {
        padding-left: calc(0.375em + var(--lumo-border-radius) / 4 - 1px + 0.25em);
      }

      [part="clear"] {
        --lumo-button-size: 15px;
        --lumo-icon-size-m: 19px;
        color: var(--lumo-contrast-60pct);
      }

      [part="no-results"] {
        width: var(--vaadin-autocomplete-options-width);
        padding: 0.5em calc(0.375em + var(--lumo-border-radius) / 4 - 1px + 0.25em);
        box-sizing: border-box;
      }

      [part="bold"] {
        font-weight: 600;
      }
    </style>

    <vaadin-text-field
      id="textField"
      on-focus="_textFieldFocused"
      label="[[label]]"
      placeholder="[[placeholder]]">
      <template is="dom-if" if="[[_hasValue(value)]]">
        <vaadin-button
          part="clear"
          theme="icon tertiary small"
          aria-label="Add new item"
          slot="suffix"
          on-click="clear">

          <iron-icon icon="vaadin:close">
          </iron-icon>

        </vaadin-button>
      </template>
    </vaadin-text-field>

    <vaadin-autocomplete-overlay opened="{{optionsShown}}">
      <template>
        <vaadin-list-box
          part="options-container">

          <template is="dom-repeat" items="[[_limitedOptions]]" as="option">
            <vaadin-item
              on-click="_optionClicked"
              part="option">
              <span part="bold">[[_getInputtedPart(value, option)]]</span>[[_getSuggestedPart(value, option)]]
            </vaadin-item>
          </template>

          <template is="dom-if" if="[[!_limitedOptions.length]]">
            <vaadin-item
              disabled
              part="option">
              No results
            </vaadin-item>
          </template>
        </vaadin-list-box>

      </template>
    </vaadin-autocomplete-overlay>

  </template>

  <script>
    {
      /**
       * `<vaadin-autocomplete>` is a template for incubator components.
       *
       * ```
       * <vaadin-autocomplete>
       * </vaadin-autocomplete>
       * ```
       *
       * @memberof Vaadin
       * @demo demo/index.html
       */
      class VaadinAutocomplete extends Vaadin.ElementMixin(
        Vaadin.ThemableMixin(
          Polymer.mixinBehaviors(Polymer.IronResizableBehavior, Polymer.Element))) {

        static get is() {
          return 'vaadin-autocomplete';
        }

        static get properties() {
          return {
            optionsShown: {
              type: Boolean,
              reflectToAttribute: true,
              value: false
            },

            value: {
              type: String,
              notify: true,
              observer: '_valueChange'
            },

            options: {
              type: Array,
              value: () => [],
              observer: '_optionsChange'
            },

            limit: {
              type: Number,
              value: 10
            },

            label: {
              type: String
            },

            placeholder: {
              type: String
            },

            _limitedOptions: {
              type: Array
            },

            _savedValue: {
              type: String
            },

            _overlayElement: Object,
            _textFieldElement: Object,
            _optionsContainer: Object,
            _selectedOption: Object,
            _boundHideOptions: Object,
            _boundSetOverlayPosition: Object,
          };
        }

        static get observers() {
          return [
            '_selectedOptionChanged(_selectedOption)'
          ];
        }

        constructor() {
          super();
          this._boundSetOverlayPosition = this._setOverlayPosition.bind(this);
          this._boundHideOptions = this.hideOptions.bind(this);
        }

        connectedCallback() {
          super.connectedCallback();

          this.$.textField.addEventListener('input', this._onInput.bind(this));
          this.addEventListener('iron-resize', this._boundSetOverlayPosition);
          this.addEventListener('click', this._elementClickListener);
          document.addEventListener('click', this._boundHideOptions);
          this.addEventListener('keydown', this._onKeyDown.bind(this));
        }

        ready() {
          super.ready();

          this._overlayElement = this.shadowRoot.querySelector('vaadin-autocomplete-overlay');
          this._textFieldElement = this.shadowRoot.querySelector('vaadin-text-field');
          this._optionsContainer = this._overlayElement.content.querySelector('vaadin-list-box');

          this._overlayElement.addEventListener('vaadin-overlay-outside-click', (ev) => ev.preventDefault());
        }

        disconnectedCallback() {
          super.disconnectedCallback();

          this.$.textField.removeEventListener('input', this._onInput.bind(this));
          this.removeEventListener('iron-resize', this._boundSetOverlayPosition);
          document.removeEventListener('click', this._boundHideOptions);
          this.removeEventListener('click', this._elementClickListener);
          this.removeEventListener('keydown', this._onKeyDown.bind(this));

          this.hideOptions();
        }

        _elementClickListener(event) {
          event.stopPropagation();
        }

        _setOverlayPosition() {
          const inputRect = this.getBoundingClientRect();

          this._overlayElement.style.left = inputRect.left + 'px';
          this._overlayElement.style.top = inputRect.bottom + 'px';

          this._overlayElement.updateStyles({'--vaadin-autocomplete-options-width': inputRect.width + 'px'});
        }

        showOptions() {
          this._setOverlayPosition();
          this.optionsShown = true;
        }

        hideOptions(event) {
          this.optionsShown = false;
        }

        _valueChange(value) {
          if (this._selectedOption) {
            this._selectedOption._setFocused(false);
            this._selectedOption = null;
          }

          if (value.length > 0 && !this.optionsShown) {
            this.showOptions();
          } else if (value.length == 0 && this.optionsShown) {
            this.hideOptions();
          }
        }

        _optionClicked(ev) {
          this._applyValue(ev.model.option);
        }

        _applyValue(value) {
          this.dispatchEvent(new CustomEvent('vaadin-autocomplete-value-applied', {
            bubbles: true,
            detail: {
              value: value
            }
          }));

          this._changeTextFieldValue(value);
          this.hideOptions();
          this.$.textField.blur();
        }

        _textFieldFocused() {
          if (this.value && this.value.length > 0) {
            this.showOptions();
          }
        }

        _hasValue(value) {
          return value.length > 0;
        }

        _optionsChange(options) {
          this._limitedOptions = options.slice(0, this.limit);
        }

        clear() {
          this._changeTextFieldValue('');
          this._textFieldElement.focus();
        }

        _getInputtedPart(value, option) {
          return option.substr(0, value.length);
        }

        _getSuggestedPart(value, option) {
          return option.substr(value.length, option.length);
        }

        _onKeyDown(event) {
          switch (event.key) {
            case 'ArrowDown':
              event.preventDefault();
              this._navigate('next');

              break;
            case 'ArrowUp':
              event.preventDefault();
              this._navigate('prev');

              break;
            case 'Enter':
              if (this._selectedOption) {
                this._applyValue(this._selectedOption.value);
              } else {
                this._applyValue(this.$.textField.value);
              }

              break;
            case 'Escape':
              this.$.textField.blur();
              this.hideOptions();

              break;
          }
        }

        _navigate(to) {
          const items = this._optionsContainer.items.filter(item => !item.disabled);

          if (!items.length) {
            return;
          }

          const index = items.indexOf(this._selectedOption);

          // Store the current value if an arrow clicked in the first time
          if (index === -1) {
            this._savedValue = this.value;
          }

          // Reset the previously selected option
          if (this._selectedOption) {
            this._selectedOption._setFocused(false);
            this._selectedOption = null;
          }

          let nextIndex;

          // Calculate where to navigate next
          if (to === 'next') {
            nextIndex = index + 1;

            // If out of bounds then navigate to -1, which means 'previously stored value'
            if (nextIndex > items.length - 1) {
              nextIndex = -1;
            }
          } else if (to === 'prev') {
            nextIndex = index - 1;

            // If out of bounds then navigate to -1, which means 'previously stored value'
            if (nextIndex < -1) {
              nextIndex = items.length - 1;
            }
          }

          // Navigate to the next option
          if (nextIndex >= 0) {
            items[nextIndex]._setFocused(true);
            this._selectedOption = items[nextIndex];

            return this._selectedOption.value;
          // or restore the saved value
          } else {
            this.$.textField.value = this._savedValue;

            return this._savedValue;
          }
        }

        _selectedOptionChanged(selectedOption) {
          if (!selectedOption) {
            return;
          }

          this.$.textField.value = selectedOption.value;
        }

        _changeTextFieldValue(newValue) {
          this.$.textField.value = newValue;
          this.$.textField.dispatchEvent(new Event('input', {
            bubbles: true,
            cancelable: true
          }));
        }

        _onInput(event) {
          this.value = event.target.value;
        }
      }

      customElements.define(VaadinAutocomplete.is, VaadinAutocomplete);

      /**
       * @namespace Vaadin
       */
      window.Vaadin.VaadinAutocomplete = VaadinAutocomplete;

      if (window.Vaadin.runIfDevelopmentMode) {
        window.Vaadin.runIfDevelopmentMode('vaadin-license-checker', VaadinAutocomplete);
      }
    }
  </script>
</dom-module>
